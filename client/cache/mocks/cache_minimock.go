// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/library/client/cache.Cache -o cache_minimock.go -n CacheMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CacheMock implements cache.Cache
type CacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExpire          func(ctx context.Context, key string, expiration time.Duration) (err error)
	inspectFuncExpire   func(ctx context.Context, key string, expiration time.Duration)
	afterExpireCounter  uint64
	beforeExpireCounter uint64
	ExpireMock          mCacheMockExpire

	funcGet          func(ctx context.Context, key string) (p1 interface{}, err error)
	inspectFuncGet   func(ctx context.Context, key string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mCacheMockGet

	funcHGetAll          func(ctx context.Context, key string) (pa1 []interface{}, err error)
	inspectFuncHGetAll   func(ctx context.Context, key string)
	afterHGetAllCounter  uint64
	beforeHGetAllCounter uint64
	HGetAllMock          mCacheMockHGetAll

	funcHashSet          func(ctx context.Context, key string, values interface{}) (err error)
	inspectFuncHashSet   func(ctx context.Context, key string, values interface{})
	afterHashSetCounter  uint64
	beforeHashSetCounter uint64
	HashSetMock          mCacheMockHashSet

	funcPing          func(ctx context.Context) (err error)
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mCacheMockPing

	funcSet          func(ctx context.Context, key string, value interface{}) (err error)
	inspectFuncSet   func(ctx context.Context, key string, value interface{})
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mCacheMockSet
}

// NewCacheMock returns a mock for cache.Cache
func NewCacheMock(t minimock.Tester) *CacheMock {
	m := &CacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExpireMock = mCacheMockExpire{mock: m}
	m.ExpireMock.callArgs = []*CacheMockExpireParams{}

	m.GetMock = mCacheMockGet{mock: m}
	m.GetMock.callArgs = []*CacheMockGetParams{}

	m.HGetAllMock = mCacheMockHGetAll{mock: m}
	m.HGetAllMock.callArgs = []*CacheMockHGetAllParams{}

	m.HashSetMock = mCacheMockHashSet{mock: m}
	m.HashSetMock.callArgs = []*CacheMockHashSetParams{}

	m.PingMock = mCacheMockPing{mock: m}
	m.PingMock.callArgs = []*CacheMockPingParams{}

	m.SetMock = mCacheMockSet{mock: m}
	m.SetMock.callArgs = []*CacheMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCacheMockExpire struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockExpireExpectation
	expectations       []*CacheMockExpireExpectation

	callArgs []*CacheMockExpireParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockExpireExpectation specifies expectation struct of the Cache.Expire
type CacheMockExpireExpectation struct {
	mock      *CacheMock
	params    *CacheMockExpireParams
	paramPtrs *CacheMockExpireParamPtrs
	results   *CacheMockExpireResults
	Counter   uint64
}

// CacheMockExpireParams contains parameters of the Cache.Expire
type CacheMockExpireParams struct {
	ctx        context.Context
	key        string
	expiration time.Duration
}

// CacheMockExpireParamPtrs contains pointers to parameters of the Cache.Expire
type CacheMockExpireParamPtrs struct {
	ctx        *context.Context
	key        *string
	expiration *time.Duration
}

// CacheMockExpireResults contains results of the Cache.Expire
type CacheMockExpireResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpire *mCacheMockExpire) Optional() *mCacheMockExpire {
	mmExpire.optional = true
	return mmExpire
}

// Expect sets up expected params for Cache.Expire
func (mmExpire *mCacheMockExpire) Expect(ctx context.Context, key string, expiration time.Duration) *mCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.paramPtrs != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by ExpectParams functions")
	}

	mmExpire.defaultExpectation.params = &CacheMockExpireParams{ctx, key, expiration}
	for _, e := range mmExpire.expectations {
		if minimock.Equal(e.params, mmExpire.defaultExpectation.params) {
			mmExpire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpire.defaultExpectation.params)
		}
	}

	return mmExpire
}

// ExpectCtxParam1 sets up expected param ctx for Cache.Expire
func (mmExpire *mCacheMockExpire) ExpectCtxParam1(ctx context.Context) *mCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &CacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.ctx = &ctx

	return mmExpire
}

// ExpectKeyParam2 sets up expected param key for Cache.Expire
func (mmExpire *mCacheMockExpire) ExpectKeyParam2(key string) *mCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &CacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.key = &key

	return mmExpire
}

// ExpectExpirationParam3 sets up expected param expiration for Cache.Expire
func (mmExpire *mCacheMockExpire) ExpectExpirationParam3(expiration time.Duration) *mCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &CacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.expiration = &expiration

	return mmExpire
}

// Inspect accepts an inspector function that has same arguments as the Cache.Expire
func (mmExpire *mCacheMockExpire) Inspect(f func(ctx context.Context, key string, expiration time.Duration)) *mCacheMockExpire {
	if mmExpire.mock.inspectFuncExpire != nil {
		mmExpire.mock.t.Fatalf("Inspect function is already set for CacheMock.Expire")
	}

	mmExpire.mock.inspectFuncExpire = f

	return mmExpire
}

// Return sets up results that will be returned by Cache.Expire
func (mmExpire *mCacheMockExpire) Return(err error) *CacheMock {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{mock: mmExpire.mock}
	}
	mmExpire.defaultExpectation.results = &CacheMockExpireResults{err}
	return mmExpire.mock
}

// Set uses given function f to mock the Cache.Expire method
func (mmExpire *mCacheMockExpire) Set(f func(ctx context.Context, key string, expiration time.Duration) (err error)) *CacheMock {
	if mmExpire.defaultExpectation != nil {
		mmExpire.mock.t.Fatalf("Default expectation is already set for the Cache.Expire method")
	}

	if len(mmExpire.expectations) > 0 {
		mmExpire.mock.t.Fatalf("Some expectations are already set for the Cache.Expire method")
	}

	mmExpire.mock.funcExpire = f
	return mmExpire.mock
}

// When sets expectation for the Cache.Expire which will trigger the result defined by the following
// Then helper
func (mmExpire *mCacheMockExpire) When(ctx context.Context, key string, expiration time.Duration) *CacheMockExpireExpectation {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	expectation := &CacheMockExpireExpectation{
		mock:   mmExpire.mock,
		params: &CacheMockExpireParams{ctx, key, expiration},
	}
	mmExpire.expectations = append(mmExpire.expectations, expectation)
	return expectation
}

// Then sets up Cache.Expire return parameters for the expectation previously defined by the When method
func (e *CacheMockExpireExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockExpireResults{err}
	return e.mock
}

// Times sets number of times Cache.Expire should be invoked
func (mmExpire *mCacheMockExpire) Times(n uint64) *mCacheMockExpire {
	if n == 0 {
		mmExpire.mock.t.Fatalf("Times of CacheMock.Expire mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpire.expectedInvocations, n)
	return mmExpire
}

func (mmExpire *mCacheMockExpire) invocationsDone() bool {
	if len(mmExpire.expectations) == 0 && mmExpire.defaultExpectation == nil && mmExpire.mock.funcExpire == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpire.mock.afterExpireCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpire.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Expire implements cache.Cache
func (mmExpire *CacheMock) Expire(ctx context.Context, key string, expiration time.Duration) (err error) {
	mm_atomic.AddUint64(&mmExpire.beforeExpireCounter, 1)
	defer mm_atomic.AddUint64(&mmExpire.afterExpireCounter, 1)

	if mmExpire.inspectFuncExpire != nil {
		mmExpire.inspectFuncExpire(ctx, key, expiration)
	}

	mm_params := CacheMockExpireParams{ctx, key, expiration}

	// Record call args
	mmExpire.ExpireMock.mutex.Lock()
	mmExpire.ExpireMock.callArgs = append(mmExpire.ExpireMock.callArgs, &mm_params)
	mmExpire.ExpireMock.mutex.Unlock()

	for _, e := range mmExpire.ExpireMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmExpire.ExpireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpire.ExpireMock.defaultExpectation.Counter, 1)
		mm_want := mmExpire.ExpireMock.defaultExpectation.params
		mm_want_ptrs := mmExpire.ExpireMock.defaultExpectation.paramPtrs

		mm_got := CacheMockExpireParams{ctx, key, expiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExpire.t.Errorf("CacheMock.Expire got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmExpire.t.Errorf("CacheMock.Expire got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.expiration != nil && !minimock.Equal(*mm_want_ptrs.expiration, mm_got.expiration) {
				mmExpire.t.Errorf("CacheMock.Expire got unexpected parameter expiration, want: %#v, got: %#v%s\n", *mm_want_ptrs.expiration, mm_got.expiration, minimock.Diff(*mm_want_ptrs.expiration, mm_got.expiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpire.t.Errorf("CacheMock.Expire got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExpire.ExpireMock.defaultExpectation.results
		if mm_results == nil {
			mmExpire.t.Fatal("No results are set for the CacheMock.Expire")
		}
		return (*mm_results).err
	}
	if mmExpire.funcExpire != nil {
		return mmExpire.funcExpire(ctx, key, expiration)
	}
	mmExpire.t.Fatalf("Unexpected call to CacheMock.Expire. %v %v %v", ctx, key, expiration)
	return
}

// ExpireAfterCounter returns a count of finished CacheMock.Expire invocations
func (mmExpire *CacheMock) ExpireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.afterExpireCounter)
}

// ExpireBeforeCounter returns a count of CacheMock.Expire invocations
func (mmExpire *CacheMock) ExpireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.beforeExpireCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Expire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpire *mCacheMockExpire) Calls() []*CacheMockExpireParams {
	mmExpire.mutex.RLock()

	argCopy := make([]*CacheMockExpireParams, len(mmExpire.callArgs))
	copy(argCopy, mmExpire.callArgs)

	mmExpire.mutex.RUnlock()

	return argCopy
}

// MinimockExpireDone returns true if the count of the Expire invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockExpireDone() bool {
	if m.ExpireMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireMock.invocationsDone()
}

// MinimockExpireInspect logs each unmet expectation
func (m *CacheMock) MinimockExpireInspect() {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Expire with params: %#v", *e.params)
		}
	}

	afterExpireCounter := mm_atomic.LoadUint64(&m.afterExpireCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && afterExpireCounter < 1 {
		if m.ExpireMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Expire")
		} else {
			m.t.Errorf("Expected call to CacheMock.Expire with params: %#v", *m.ExpireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && afterExpireCounter < 1 {
		m.t.Error("Expected call to CacheMock.Expire")
	}

	if !m.ExpireMock.invocationsDone() && afterExpireCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Expire but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireMock.expectedInvocations), afterExpireCounter)
	}
}

type mCacheMockGet struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockGetExpectation
	expectations       []*CacheMockGetExpectation

	callArgs []*CacheMockGetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockGetExpectation specifies expectation struct of the Cache.Get
type CacheMockGetExpectation struct {
	mock      *CacheMock
	params    *CacheMockGetParams
	paramPtrs *CacheMockGetParamPtrs
	results   *CacheMockGetResults
	Counter   uint64
}

// CacheMockGetParams contains parameters of the Cache.Get
type CacheMockGetParams struct {
	ctx context.Context
	key string
}

// CacheMockGetParamPtrs contains pointers to parameters of the Cache.Get
type CacheMockGetParamPtrs struct {
	ctx *context.Context
	key *string
}

// CacheMockGetResults contains results of the Cache.Get
type CacheMockGetResults struct {
	p1  interface{}
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mCacheMockGet) Optional() *mCacheMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Cache.Get
func (mmGet *mCacheMockGet) Expect(ctx context.Context, key string) *mCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &CacheMockGetParams{ctx, key}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Cache.Get
func (mmGet *mCacheMockGet) ExpectCtxParam1(ctx context.Context) *mCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for Cache.Get
func (mmGet *mCacheMockGet) ExpectKeyParam2(key string) *mCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Cache.Get
func (mmGet *mCacheMockGet) Inspect(f func(ctx context.Context, key string)) *mCacheMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for CacheMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Cache.Get
func (mmGet *mCacheMockGet) Return(p1 interface{}, err error) *CacheMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &CacheMockGetResults{p1, err}
	return mmGet.mock
}

// Set uses given function f to mock the Cache.Get method
func (mmGet *mCacheMockGet) Set(f func(ctx context.Context, key string) (p1 interface{}, err error)) *CacheMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Cache.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Cache.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Cache.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mCacheMockGet) When(ctx context.Context, key string) *CacheMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	expectation := &CacheMockGetExpectation{
		mock:   mmGet.mock,
		params: &CacheMockGetParams{ctx, key},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Cache.Get return parameters for the expectation previously defined by the When method
func (e *CacheMockGetExpectation) Then(p1 interface{}, err error) *CacheMock {
	e.results = &CacheMockGetResults{p1, err}
	return e.mock
}

// Times sets number of times Cache.Get should be invoked
func (mmGet *mCacheMockGet) Times(n uint64) *mCacheMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of CacheMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	return mmGet
}

func (mmGet *mCacheMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements cache.Cache
func (mmGet *CacheMock) Get(ctx context.Context, key string) (p1 interface{}, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key)
	}

	mm_params := CacheMockGetParams{ctx, key}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := CacheMockGetParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("CacheMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("CacheMock.Get got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("CacheMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the CacheMock.Get")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key)
	}
	mmGet.t.Fatalf("Unexpected call to CacheMock.Get. %v %v", ctx, key)
	return
}

// GetAfterCounter returns a count of finished CacheMock.Get invocations
func (mmGet *CacheMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of CacheMock.Get invocations
func (mmGet *CacheMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mCacheMockGet) Calls() []*CacheMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*CacheMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *CacheMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Get with params: %#v", *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Get")
		} else {
			m.t.Errorf("Expected call to CacheMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Error("Expected call to CacheMock.Get")
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Get but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), afterGetCounter)
	}
}

type mCacheMockHGetAll struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockHGetAllExpectation
	expectations       []*CacheMockHGetAllExpectation

	callArgs []*CacheMockHGetAllParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockHGetAllExpectation specifies expectation struct of the Cache.HGetAll
type CacheMockHGetAllExpectation struct {
	mock      *CacheMock
	params    *CacheMockHGetAllParams
	paramPtrs *CacheMockHGetAllParamPtrs
	results   *CacheMockHGetAllResults
	Counter   uint64
}

// CacheMockHGetAllParams contains parameters of the Cache.HGetAll
type CacheMockHGetAllParams struct {
	ctx context.Context
	key string
}

// CacheMockHGetAllParamPtrs contains pointers to parameters of the Cache.HGetAll
type CacheMockHGetAllParamPtrs struct {
	ctx *context.Context
	key *string
}

// CacheMockHGetAllResults contains results of the Cache.HGetAll
type CacheMockHGetAllResults struct {
	pa1 []interface{}
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHGetAll *mCacheMockHGetAll) Optional() *mCacheMockHGetAll {
	mmHGetAll.optional = true
	return mmHGetAll
}

// Expect sets up expected params for Cache.HGetAll
func (mmHGetAll *mCacheMockHGetAll) Expect(ctx context.Context, key string) *mCacheMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("CacheMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &CacheMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.paramPtrs != nil {
		mmHGetAll.mock.t.Fatalf("CacheMock.HGetAll mock is already set by ExpectParams functions")
	}

	mmHGetAll.defaultExpectation.params = &CacheMockHGetAllParams{ctx, key}
	for _, e := range mmHGetAll.expectations {
		if minimock.Equal(e.params, mmHGetAll.defaultExpectation.params) {
			mmHGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHGetAll.defaultExpectation.params)
		}
	}

	return mmHGetAll
}

// ExpectCtxParam1 sets up expected param ctx for Cache.HGetAll
func (mmHGetAll *mCacheMockHGetAll) ExpectCtxParam1(ctx context.Context) *mCacheMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("CacheMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &CacheMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.params != nil {
		mmHGetAll.mock.t.Fatalf("CacheMock.HGetAll mock is already set by Expect")
	}

	if mmHGetAll.defaultExpectation.paramPtrs == nil {
		mmHGetAll.defaultExpectation.paramPtrs = &CacheMockHGetAllParamPtrs{}
	}
	mmHGetAll.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHGetAll
}

// ExpectKeyParam2 sets up expected param key for Cache.HGetAll
func (mmHGetAll *mCacheMockHGetAll) ExpectKeyParam2(key string) *mCacheMockHGetAll {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("CacheMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &CacheMockHGetAllExpectation{}
	}

	if mmHGetAll.defaultExpectation.params != nil {
		mmHGetAll.mock.t.Fatalf("CacheMock.HGetAll mock is already set by Expect")
	}

	if mmHGetAll.defaultExpectation.paramPtrs == nil {
		mmHGetAll.defaultExpectation.paramPtrs = &CacheMockHGetAllParamPtrs{}
	}
	mmHGetAll.defaultExpectation.paramPtrs.key = &key

	return mmHGetAll
}

// Inspect accepts an inspector function that has same arguments as the Cache.HGetAll
func (mmHGetAll *mCacheMockHGetAll) Inspect(f func(ctx context.Context, key string)) *mCacheMockHGetAll {
	if mmHGetAll.mock.inspectFuncHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("Inspect function is already set for CacheMock.HGetAll")
	}

	mmHGetAll.mock.inspectFuncHGetAll = f

	return mmHGetAll
}

// Return sets up results that will be returned by Cache.HGetAll
func (mmHGetAll *mCacheMockHGetAll) Return(pa1 []interface{}, err error) *CacheMock {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("CacheMock.HGetAll mock is already set by Set")
	}

	if mmHGetAll.defaultExpectation == nil {
		mmHGetAll.defaultExpectation = &CacheMockHGetAllExpectation{mock: mmHGetAll.mock}
	}
	mmHGetAll.defaultExpectation.results = &CacheMockHGetAllResults{pa1, err}
	return mmHGetAll.mock
}

// Set uses given function f to mock the Cache.HGetAll method
func (mmHGetAll *mCacheMockHGetAll) Set(f func(ctx context.Context, key string) (pa1 []interface{}, err error)) *CacheMock {
	if mmHGetAll.defaultExpectation != nil {
		mmHGetAll.mock.t.Fatalf("Default expectation is already set for the Cache.HGetAll method")
	}

	if len(mmHGetAll.expectations) > 0 {
		mmHGetAll.mock.t.Fatalf("Some expectations are already set for the Cache.HGetAll method")
	}

	mmHGetAll.mock.funcHGetAll = f
	return mmHGetAll.mock
}

// When sets expectation for the Cache.HGetAll which will trigger the result defined by the following
// Then helper
func (mmHGetAll *mCacheMockHGetAll) When(ctx context.Context, key string) *CacheMockHGetAllExpectation {
	if mmHGetAll.mock.funcHGetAll != nil {
		mmHGetAll.mock.t.Fatalf("CacheMock.HGetAll mock is already set by Set")
	}

	expectation := &CacheMockHGetAllExpectation{
		mock:   mmHGetAll.mock,
		params: &CacheMockHGetAllParams{ctx, key},
	}
	mmHGetAll.expectations = append(mmHGetAll.expectations, expectation)
	return expectation
}

// Then sets up Cache.HGetAll return parameters for the expectation previously defined by the When method
func (e *CacheMockHGetAllExpectation) Then(pa1 []interface{}, err error) *CacheMock {
	e.results = &CacheMockHGetAllResults{pa1, err}
	return e.mock
}

// Times sets number of times Cache.HGetAll should be invoked
func (mmHGetAll *mCacheMockHGetAll) Times(n uint64) *mCacheMockHGetAll {
	if n == 0 {
		mmHGetAll.mock.t.Fatalf("Times of CacheMock.HGetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHGetAll.expectedInvocations, n)
	return mmHGetAll
}

func (mmHGetAll *mCacheMockHGetAll) invocationsDone() bool {
	if len(mmHGetAll.expectations) == 0 && mmHGetAll.defaultExpectation == nil && mmHGetAll.mock.funcHGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHGetAll.mock.afterHGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HGetAll implements cache.Cache
func (mmHGetAll *CacheMock) HGetAll(ctx context.Context, key string) (pa1 []interface{}, err error) {
	mm_atomic.AddUint64(&mmHGetAll.beforeHGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmHGetAll.afterHGetAllCounter, 1)

	if mmHGetAll.inspectFuncHGetAll != nil {
		mmHGetAll.inspectFuncHGetAll(ctx, key)
	}

	mm_params := CacheMockHGetAllParams{ctx, key}

	// Record call args
	mmHGetAll.HGetAllMock.mutex.Lock()
	mmHGetAll.HGetAllMock.callArgs = append(mmHGetAll.HGetAllMock.callArgs, &mm_params)
	mmHGetAll.HGetAllMock.mutex.Unlock()

	for _, e := range mmHGetAll.HGetAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmHGetAll.HGetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHGetAll.HGetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmHGetAll.HGetAllMock.defaultExpectation.params
		mm_want_ptrs := mmHGetAll.HGetAllMock.defaultExpectation.paramPtrs

		mm_got := CacheMockHGetAllParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHGetAll.t.Errorf("CacheMock.HGetAll got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHGetAll.t.Errorf("CacheMock.HGetAll got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHGetAll.t.Errorf("CacheMock.HGetAll got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHGetAll.HGetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmHGetAll.t.Fatal("No results are set for the CacheMock.HGetAll")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmHGetAll.funcHGetAll != nil {
		return mmHGetAll.funcHGetAll(ctx, key)
	}
	mmHGetAll.t.Fatalf("Unexpected call to CacheMock.HGetAll. %v %v", ctx, key)
	return
}

// HGetAllAfterCounter returns a count of finished CacheMock.HGetAll invocations
func (mmHGetAll *CacheMock) HGetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGetAll.afterHGetAllCounter)
}

// HGetAllBeforeCounter returns a count of CacheMock.HGetAll invocations
func (mmHGetAll *CacheMock) HGetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGetAll.beforeHGetAllCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.HGetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHGetAll *mCacheMockHGetAll) Calls() []*CacheMockHGetAllParams {
	mmHGetAll.mutex.RLock()

	argCopy := make([]*CacheMockHGetAllParams, len(mmHGetAll.callArgs))
	copy(argCopy, mmHGetAll.callArgs)

	mmHGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockHGetAllDone returns true if the count of the HGetAll invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockHGetAllDone() bool {
	if m.HGetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HGetAllMock.invocationsDone()
}

// MinimockHGetAllInspect logs each unmet expectation
func (m *CacheMock) MinimockHGetAllInspect() {
	for _, e := range m.HGetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.HGetAll with params: %#v", *e.params)
		}
	}

	afterHGetAllCounter := mm_atomic.LoadUint64(&m.afterHGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HGetAllMock.defaultExpectation != nil && afterHGetAllCounter < 1 {
		if m.HGetAllMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.HGetAll")
		} else {
			m.t.Errorf("Expected call to CacheMock.HGetAll with params: %#v", *m.HGetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHGetAll != nil && afterHGetAllCounter < 1 {
		m.t.Error("Expected call to CacheMock.HGetAll")
	}

	if !m.HGetAllMock.invocationsDone() && afterHGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.HGetAll but found %d calls",
			mm_atomic.LoadUint64(&m.HGetAllMock.expectedInvocations), afterHGetAllCounter)
	}
}

type mCacheMockHashSet struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockHashSetExpectation
	expectations       []*CacheMockHashSetExpectation

	callArgs []*CacheMockHashSetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockHashSetExpectation specifies expectation struct of the Cache.HashSet
type CacheMockHashSetExpectation struct {
	mock      *CacheMock
	params    *CacheMockHashSetParams
	paramPtrs *CacheMockHashSetParamPtrs
	results   *CacheMockHashSetResults
	Counter   uint64
}

// CacheMockHashSetParams contains parameters of the Cache.HashSet
type CacheMockHashSetParams struct {
	ctx    context.Context
	key    string
	values interface{}
}

// CacheMockHashSetParamPtrs contains pointers to parameters of the Cache.HashSet
type CacheMockHashSetParamPtrs struct {
	ctx    *context.Context
	key    *string
	values *interface{}
}

// CacheMockHashSetResults contains results of the Cache.HashSet
type CacheMockHashSetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHashSet *mCacheMockHashSet) Optional() *mCacheMockHashSet {
	mmHashSet.optional = true
	return mmHashSet
}

// Expect sets up expected params for Cache.HashSet
func (mmHashSet *mCacheMockHashSet) Expect(ctx context.Context, key string, values interface{}) *mCacheMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &CacheMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.paramPtrs != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by ExpectParams functions")
	}

	mmHashSet.defaultExpectation.params = &CacheMockHashSetParams{ctx, key, values}
	for _, e := range mmHashSet.expectations {
		if minimock.Equal(e.params, mmHashSet.defaultExpectation.params) {
			mmHashSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHashSet.defaultExpectation.params)
		}
	}

	return mmHashSet
}

// ExpectCtxParam1 sets up expected param ctx for Cache.HashSet
func (mmHashSet *mCacheMockHashSet) ExpectCtxParam1(ctx context.Context) *mCacheMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &CacheMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &CacheMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHashSet
}

// ExpectKeyParam2 sets up expected param key for Cache.HashSet
func (mmHashSet *mCacheMockHashSet) ExpectKeyParam2(key string) *mCacheMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &CacheMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &CacheMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.key = &key

	return mmHashSet
}

// ExpectValuesParam3 sets up expected param values for Cache.HashSet
func (mmHashSet *mCacheMockHashSet) ExpectValuesParam3(values interface{}) *mCacheMockHashSet {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &CacheMockHashSetExpectation{}
	}

	if mmHashSet.defaultExpectation.params != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Expect")
	}

	if mmHashSet.defaultExpectation.paramPtrs == nil {
		mmHashSet.defaultExpectation.paramPtrs = &CacheMockHashSetParamPtrs{}
	}
	mmHashSet.defaultExpectation.paramPtrs.values = &values

	return mmHashSet
}

// Inspect accepts an inspector function that has same arguments as the Cache.HashSet
func (mmHashSet *mCacheMockHashSet) Inspect(f func(ctx context.Context, key string, values interface{})) *mCacheMockHashSet {
	if mmHashSet.mock.inspectFuncHashSet != nil {
		mmHashSet.mock.t.Fatalf("Inspect function is already set for CacheMock.HashSet")
	}

	mmHashSet.mock.inspectFuncHashSet = f

	return mmHashSet
}

// Return sets up results that will be returned by Cache.HashSet
func (mmHashSet *mCacheMockHashSet) Return(err error) *CacheMock {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Set")
	}

	if mmHashSet.defaultExpectation == nil {
		mmHashSet.defaultExpectation = &CacheMockHashSetExpectation{mock: mmHashSet.mock}
	}
	mmHashSet.defaultExpectation.results = &CacheMockHashSetResults{err}
	return mmHashSet.mock
}

// Set uses given function f to mock the Cache.HashSet method
func (mmHashSet *mCacheMockHashSet) Set(f func(ctx context.Context, key string, values interface{}) (err error)) *CacheMock {
	if mmHashSet.defaultExpectation != nil {
		mmHashSet.mock.t.Fatalf("Default expectation is already set for the Cache.HashSet method")
	}

	if len(mmHashSet.expectations) > 0 {
		mmHashSet.mock.t.Fatalf("Some expectations are already set for the Cache.HashSet method")
	}

	mmHashSet.mock.funcHashSet = f
	return mmHashSet.mock
}

// When sets expectation for the Cache.HashSet which will trigger the result defined by the following
// Then helper
func (mmHashSet *mCacheMockHashSet) When(ctx context.Context, key string, values interface{}) *CacheMockHashSetExpectation {
	if mmHashSet.mock.funcHashSet != nil {
		mmHashSet.mock.t.Fatalf("CacheMock.HashSet mock is already set by Set")
	}

	expectation := &CacheMockHashSetExpectation{
		mock:   mmHashSet.mock,
		params: &CacheMockHashSetParams{ctx, key, values},
	}
	mmHashSet.expectations = append(mmHashSet.expectations, expectation)
	return expectation
}

// Then sets up Cache.HashSet return parameters for the expectation previously defined by the When method
func (e *CacheMockHashSetExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockHashSetResults{err}
	return e.mock
}

// Times sets number of times Cache.HashSet should be invoked
func (mmHashSet *mCacheMockHashSet) Times(n uint64) *mCacheMockHashSet {
	if n == 0 {
		mmHashSet.mock.t.Fatalf("Times of CacheMock.HashSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHashSet.expectedInvocations, n)
	return mmHashSet
}

func (mmHashSet *mCacheMockHashSet) invocationsDone() bool {
	if len(mmHashSet.expectations) == 0 && mmHashSet.defaultExpectation == nil && mmHashSet.mock.funcHashSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHashSet.mock.afterHashSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHashSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HashSet implements cache.Cache
func (mmHashSet *CacheMock) HashSet(ctx context.Context, key string, values interface{}) (err error) {
	mm_atomic.AddUint64(&mmHashSet.beforeHashSetCounter, 1)
	defer mm_atomic.AddUint64(&mmHashSet.afterHashSetCounter, 1)

	if mmHashSet.inspectFuncHashSet != nil {
		mmHashSet.inspectFuncHashSet(ctx, key, values)
	}

	mm_params := CacheMockHashSetParams{ctx, key, values}

	// Record call args
	mmHashSet.HashSetMock.mutex.Lock()
	mmHashSet.HashSetMock.callArgs = append(mmHashSet.HashSetMock.callArgs, &mm_params)
	mmHashSet.HashSetMock.mutex.Unlock()

	for _, e := range mmHashSet.HashSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHashSet.HashSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHashSet.HashSetMock.defaultExpectation.Counter, 1)
		mm_want := mmHashSet.HashSetMock.defaultExpectation.params
		mm_want_ptrs := mmHashSet.HashSetMock.defaultExpectation.paramPtrs

		mm_got := CacheMockHashSetParams{ctx, key, values}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHashSet.t.Errorf("CacheMock.HashSet got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHashSet.t.Errorf("CacheMock.HashSet got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.values != nil && !minimock.Equal(*mm_want_ptrs.values, mm_got.values) {
				mmHashSet.t.Errorf("CacheMock.HashSet got unexpected parameter values, want: %#v, got: %#v%s\n", *mm_want_ptrs.values, mm_got.values, minimock.Diff(*mm_want_ptrs.values, mm_got.values))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHashSet.t.Errorf("CacheMock.HashSet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHashSet.HashSetMock.defaultExpectation.results
		if mm_results == nil {
			mmHashSet.t.Fatal("No results are set for the CacheMock.HashSet")
		}
		return (*mm_results).err
	}
	if mmHashSet.funcHashSet != nil {
		return mmHashSet.funcHashSet(ctx, key, values)
	}
	mmHashSet.t.Fatalf("Unexpected call to CacheMock.HashSet. %v %v %v", ctx, key, values)
	return
}

// HashSetAfterCounter returns a count of finished CacheMock.HashSet invocations
func (mmHashSet *CacheMock) HashSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashSet.afterHashSetCounter)
}

// HashSetBeforeCounter returns a count of CacheMock.HashSet invocations
func (mmHashSet *CacheMock) HashSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashSet.beforeHashSetCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.HashSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHashSet *mCacheMockHashSet) Calls() []*CacheMockHashSetParams {
	mmHashSet.mutex.RLock()

	argCopy := make([]*CacheMockHashSetParams, len(mmHashSet.callArgs))
	copy(argCopy, mmHashSet.callArgs)

	mmHashSet.mutex.RUnlock()

	return argCopy
}

// MinimockHashSetDone returns true if the count of the HashSet invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockHashSetDone() bool {
	if m.HashSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HashSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HashSetMock.invocationsDone()
}

// MinimockHashSetInspect logs each unmet expectation
func (m *CacheMock) MinimockHashSetInspect() {
	for _, e := range m.HashSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.HashSet with params: %#v", *e.params)
		}
	}

	afterHashSetCounter := mm_atomic.LoadUint64(&m.afterHashSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HashSetMock.defaultExpectation != nil && afterHashSetCounter < 1 {
		if m.HashSetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.HashSet")
		} else {
			m.t.Errorf("Expected call to CacheMock.HashSet with params: %#v", *m.HashSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHashSet != nil && afterHashSetCounter < 1 {
		m.t.Error("Expected call to CacheMock.HashSet")
	}

	if !m.HashSetMock.invocationsDone() && afterHashSetCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.HashSet but found %d calls",
			mm_atomic.LoadUint64(&m.HashSetMock.expectedInvocations), afterHashSetCounter)
	}
}

type mCacheMockPing struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockPingExpectation
	expectations       []*CacheMockPingExpectation

	callArgs []*CacheMockPingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockPingExpectation specifies expectation struct of the Cache.Ping
type CacheMockPingExpectation struct {
	mock      *CacheMock
	params    *CacheMockPingParams
	paramPtrs *CacheMockPingParamPtrs
	results   *CacheMockPingResults
	Counter   uint64
}

// CacheMockPingParams contains parameters of the Cache.Ping
type CacheMockPingParams struct {
	ctx context.Context
}

// CacheMockPingParamPtrs contains pointers to parameters of the Cache.Ping
type CacheMockPingParamPtrs struct {
	ctx *context.Context
}

// CacheMockPingResults contains results of the Cache.Ping
type CacheMockPingResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPing *mCacheMockPing) Optional() *mCacheMockPing {
	mmPing.optional = true
	return mmPing
}

// Expect sets up expected params for Cache.Ping
func (mmPing *mCacheMockPing) Expect(ctx context.Context) *mCacheMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &CacheMockPingExpectation{}
	}

	if mmPing.defaultExpectation.paramPtrs != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by ExpectParams functions")
	}

	mmPing.defaultExpectation.params = &CacheMockPingParams{ctx}
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// ExpectCtxParam1 sets up expected param ctx for Cache.Ping
func (mmPing *mCacheMockPing) ExpectCtxParam1(ctx context.Context) *mCacheMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &CacheMockPingExpectation{}
	}

	if mmPing.defaultExpectation.params != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Expect")
	}

	if mmPing.defaultExpectation.paramPtrs == nil {
		mmPing.defaultExpectation.paramPtrs = &CacheMockPingParamPtrs{}
	}
	mmPing.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the Cache.Ping
func (mmPing *mCacheMockPing) Inspect(f func(ctx context.Context)) *mCacheMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for CacheMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by Cache.Ping
func (mmPing *mCacheMockPing) Return(err error) *CacheMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &CacheMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &CacheMockPingResults{err}
	return mmPing.mock
}

// Set uses given function f to mock the Cache.Ping method
func (mmPing *mCacheMockPing) Set(f func(ctx context.Context) (err error)) *CacheMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the Cache.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the Cache.Ping method")
	}

	mmPing.mock.funcPing = f
	return mmPing.mock
}

// When sets expectation for the Cache.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mCacheMockPing) When(ctx context.Context) *CacheMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Set")
	}

	expectation := &CacheMockPingExpectation{
		mock:   mmPing.mock,
		params: &CacheMockPingParams{ctx},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up Cache.Ping return parameters for the expectation previously defined by the When method
func (e *CacheMockPingExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockPingResults{err}
	return e.mock
}

// Times sets number of times Cache.Ping should be invoked
func (mmPing *mCacheMockPing) Times(n uint64) *mCacheMockPing {
	if n == 0 {
		mmPing.mock.t.Fatalf("Times of CacheMock.Ping mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPing.expectedInvocations, n)
	return mmPing
}

func (mmPing *mCacheMockPing) invocationsDone() bool {
	if len(mmPing.expectations) == 0 && mmPing.defaultExpectation == nil && mmPing.mock.funcPing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPing.mock.afterPingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ping implements cache.Cache
func (mmPing *CacheMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := CacheMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_want_ptrs := mmPing.PingMock.defaultExpectation.paramPtrs

		mm_got := CacheMockPingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPing.t.Errorf("CacheMock.Ping got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("CacheMock.Ping got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the CacheMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to CacheMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished CacheMock.Ping invocations
func (mmPing *CacheMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of CacheMock.Ping invocations
func (mmPing *CacheMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mCacheMockPing) Calls() []*CacheMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*CacheMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockPingDone() bool {
	if m.PingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PingMock.invocationsDone()
}

// MinimockPingInspect logs each unmet expectation
func (m *CacheMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Ping with params: %#v", *e.params)
		}
	}

	afterPingCounter := mm_atomic.LoadUint64(&m.afterPingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && afterPingCounter < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Ping")
		} else {
			m.t.Errorf("Expected call to CacheMock.Ping with params: %#v", *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && afterPingCounter < 1 {
		m.t.Error("Expected call to CacheMock.Ping")
	}

	if !m.PingMock.invocationsDone() && afterPingCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Ping but found %d calls",
			mm_atomic.LoadUint64(&m.PingMock.expectedInvocations), afterPingCounter)
	}
}

type mCacheMockSet struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockSetExpectation
	expectations       []*CacheMockSetExpectation

	callArgs []*CacheMockSetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockSetExpectation specifies expectation struct of the Cache.Set
type CacheMockSetExpectation struct {
	mock      *CacheMock
	params    *CacheMockSetParams
	paramPtrs *CacheMockSetParamPtrs
	results   *CacheMockSetResults
	Counter   uint64
}

// CacheMockSetParams contains parameters of the Cache.Set
type CacheMockSetParams struct {
	ctx   context.Context
	key   string
	value interface{}
}

// CacheMockSetParamPtrs contains pointers to parameters of the Cache.Set
type CacheMockSetParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *interface{}
}

// CacheMockSetResults contains results of the Cache.Set
type CacheMockSetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mCacheMockSet) Optional() *mCacheMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for Cache.Set
func (mmSet *mCacheMockSet) Expect(ctx context.Context, key string, value interface{}) *mCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &CacheMockSetParams{ctx, key, value}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for Cache.Set
func (mmSet *mCacheMockSet) ExpectCtxParam1(ctx context.Context) *mCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &CacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSet
}

// ExpectKeyParam2 sets up expected param key for Cache.Set
func (mmSet *mCacheMockSet) ExpectKeyParam2(key string) *mCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &CacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.key = &key

	return mmSet
}

// ExpectValueParam3 sets up expected param value for Cache.Set
func (mmSet *mCacheMockSet) ExpectValueParam3(value interface{}) *mCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &CacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the Cache.Set
func (mmSet *mCacheMockSet) Inspect(f func(ctx context.Context, key string, value interface{})) *mCacheMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for CacheMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by Cache.Set
func (mmSet *mCacheMockSet) Return(err error) *CacheMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &CacheMockSetResults{err}
	return mmSet.mock
}

// Set uses given function f to mock the Cache.Set method
func (mmSet *mCacheMockSet) Set(f func(ctx context.Context, key string, value interface{}) (err error)) *CacheMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the Cache.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the Cache.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// When sets expectation for the Cache.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mCacheMockSet) When(ctx context.Context, key string, value interface{}) *CacheMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	expectation := &CacheMockSetExpectation{
		mock:   mmSet.mock,
		params: &CacheMockSetParams{ctx, key, value},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up Cache.Set return parameters for the expectation previously defined by the When method
func (e *CacheMockSetExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockSetResults{err}
	return e.mock
}

// Times sets number of times Cache.Set should be invoked
func (mmSet *mCacheMockSet) Times(n uint64) *mCacheMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of CacheMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	return mmSet
}

func (mmSet *mCacheMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements cache.Cache
func (mmSet *CacheMock) Set(ctx context.Context, key string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, key, value)
	}

	mm_params := CacheMockSetParams{ctx, key, value}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := CacheMockSetParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("CacheMock.Set got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSet.t.Errorf("CacheMock.Set got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("CacheMock.Set got unexpected parameter value, want: %#v, got: %#v%s\n", *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("CacheMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the CacheMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, key, value)
	}
	mmSet.t.Fatalf("Unexpected call to CacheMock.Set. %v %v %v", ctx, key, value)
	return
}

// SetAfterCounter returns a count of finished CacheMock.Set invocations
func (mmSet *CacheMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of CacheMock.Set invocations
func (mmSet *CacheMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mCacheMockSet) Calls() []*CacheMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*CacheMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *CacheMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Set with params: %#v", *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Set")
		} else {
			m.t.Errorf("Expected call to CacheMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Error("Expected call to CacheMock.Set")
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Set but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExpireInspect()

			m.MinimockGetInspect()

			m.MinimockHGetAllInspect()

			m.MinimockHashSetInspect()

			m.MinimockPingInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExpireDone() &&
		m.MinimockGetDone() &&
		m.MinimockHGetAllDone() &&
		m.MinimockHashSetDone() &&
		m.MinimockPingDone() &&
		m.MinimockSetDone()
}
