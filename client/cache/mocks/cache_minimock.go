// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ArtEmerged/library/client/cache.Cache -o cache_minimock.go -n CacheMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CacheMock implements cache.Cache
type CacheMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mCacheMockClose

	funcExpire          func(ctx context.Context, key string, expiration time.Duration) (err error)
	inspectFuncExpire   func(ctx context.Context, key string, expiration time.Duration)
	afterExpireCounter  uint64
	beforeExpireCounter uint64
	ExpireMock          mCacheMockExpire

	funcGet          func(ctx context.Context, key string, in interface{}) (err error)
	inspectFuncGet   func(ctx context.Context, key string, in interface{})
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mCacheMockGet

	funcHDel          func(ctx context.Context, key string, field ...string) (err error)
	inspectFuncHDel   func(ctx context.Context, key string, field ...string)
	afterHDelCounter  uint64
	beforeHDelCounter uint64
	HDelMock          mCacheMockHDel

	funcHGet          func(ctx context.Context, key string, field string, in interface{}) (err error)
	inspectFuncHGet   func(ctx context.Context, key string, field string, in interface{})
	afterHGetCounter  uint64
	beforeHGetCounter uint64
	HGetMock          mCacheMockHGet

	funcHSet          func(ctx context.Context, key string, field string, value interface{}) (err error)
	inspectFuncHSet   func(ctx context.Context, key string, field string, value interface{})
	afterHSetCounter  uint64
	beforeHSetCounter uint64
	HSetMock          mCacheMockHSet

	funcPing          func(ctx context.Context) (err error)
	inspectFuncPing   func(ctx context.Context)
	afterPingCounter  uint64
	beforePingCounter uint64
	PingMock          mCacheMockPing

	funcSet          func(ctx context.Context, key string, value interface{}) (err error)
	inspectFuncSet   func(ctx context.Context, key string, value interface{})
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mCacheMockSet
}

// NewCacheMock returns a mock for cache.Cache
func NewCacheMock(t minimock.Tester) *CacheMock {
	m := &CacheMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseMock = mCacheMockClose{mock: m}

	m.ExpireMock = mCacheMockExpire{mock: m}
	m.ExpireMock.callArgs = []*CacheMockExpireParams{}

	m.GetMock = mCacheMockGet{mock: m}
	m.GetMock.callArgs = []*CacheMockGetParams{}

	m.HDelMock = mCacheMockHDel{mock: m}
	m.HDelMock.callArgs = []*CacheMockHDelParams{}

	m.HGetMock = mCacheMockHGet{mock: m}
	m.HGetMock.callArgs = []*CacheMockHGetParams{}

	m.HSetMock = mCacheMockHSet{mock: m}
	m.HSetMock.callArgs = []*CacheMockHSetParams{}

	m.PingMock = mCacheMockPing{mock: m}
	m.PingMock.callArgs = []*CacheMockPingParams{}

	m.SetMock = mCacheMockSet{mock: m}
	m.SetMock.callArgs = []*CacheMockSetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCacheMockClose struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockCloseExpectation
	expectations       []*CacheMockCloseExpectation

	expectedInvocations uint64
}

// CacheMockCloseExpectation specifies expectation struct of the Cache.Close
type CacheMockCloseExpectation struct {
	mock *CacheMock

	results *CacheMockCloseResults
	Counter uint64
}

// CacheMockCloseResults contains results of the Cache.Close
type CacheMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mCacheMockClose) Optional() *mCacheMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for Cache.Close
func (mmClose *mCacheMockClose) Expect() *mCacheMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("CacheMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &CacheMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Cache.Close
func (mmClose *mCacheMockClose) Inspect(f func()) *mCacheMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for CacheMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Cache.Close
func (mmClose *mCacheMockClose) Return(err error) *CacheMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("CacheMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &CacheMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &CacheMockCloseResults{err}
	return mmClose.mock
}

// Set uses given function f to mock the Cache.Close method
func (mmClose *mCacheMockClose) Set(f func() (err error)) *CacheMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Cache.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Cache.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Times sets number of times Cache.Close should be invoked
func (mmClose *mCacheMockClose) Times(n uint64) *mCacheMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of CacheMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	return mmClose
}

func (mmClose *mCacheMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements cache.Cache
func (mmClose *CacheMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the CacheMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to CacheMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished CacheMock.Close invocations
func (mmClose *CacheMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of CacheMock.Close invocations
func (mmClose *CacheMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *CacheMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to CacheMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Error("Expected call to CacheMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Error("Expected call to CacheMock.Close")
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Close but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), afterCloseCounter)
	}
}

type mCacheMockExpire struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockExpireExpectation
	expectations       []*CacheMockExpireExpectation

	callArgs []*CacheMockExpireParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockExpireExpectation specifies expectation struct of the Cache.Expire
type CacheMockExpireExpectation struct {
	mock      *CacheMock
	params    *CacheMockExpireParams
	paramPtrs *CacheMockExpireParamPtrs
	results   *CacheMockExpireResults
	Counter   uint64
}

// CacheMockExpireParams contains parameters of the Cache.Expire
type CacheMockExpireParams struct {
	ctx        context.Context
	key        string
	expiration time.Duration
}

// CacheMockExpireParamPtrs contains pointers to parameters of the Cache.Expire
type CacheMockExpireParamPtrs struct {
	ctx        *context.Context
	key        *string
	expiration *time.Duration
}

// CacheMockExpireResults contains results of the Cache.Expire
type CacheMockExpireResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpire *mCacheMockExpire) Optional() *mCacheMockExpire {
	mmExpire.optional = true
	return mmExpire
}

// Expect sets up expected params for Cache.Expire
func (mmExpire *mCacheMockExpire) Expect(ctx context.Context, key string, expiration time.Duration) *mCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.paramPtrs != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by ExpectParams functions")
	}

	mmExpire.defaultExpectation.params = &CacheMockExpireParams{ctx, key, expiration}
	for _, e := range mmExpire.expectations {
		if minimock.Equal(e.params, mmExpire.defaultExpectation.params) {
			mmExpire.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpire.defaultExpectation.params)
		}
	}

	return mmExpire
}

// ExpectCtxParam1 sets up expected param ctx for Cache.Expire
func (mmExpire *mCacheMockExpire) ExpectCtxParam1(ctx context.Context) *mCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &CacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.ctx = &ctx

	return mmExpire
}

// ExpectKeyParam2 sets up expected param key for Cache.Expire
func (mmExpire *mCacheMockExpire) ExpectKeyParam2(key string) *mCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &CacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.key = &key

	return mmExpire
}

// ExpectExpirationParam3 sets up expected param expiration for Cache.Expire
func (mmExpire *mCacheMockExpire) ExpectExpirationParam3(expiration time.Duration) *mCacheMockExpire {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{}
	}

	if mmExpire.defaultExpectation.params != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Expect")
	}

	if mmExpire.defaultExpectation.paramPtrs == nil {
		mmExpire.defaultExpectation.paramPtrs = &CacheMockExpireParamPtrs{}
	}
	mmExpire.defaultExpectation.paramPtrs.expiration = &expiration

	return mmExpire
}

// Inspect accepts an inspector function that has same arguments as the Cache.Expire
func (mmExpire *mCacheMockExpire) Inspect(f func(ctx context.Context, key string, expiration time.Duration)) *mCacheMockExpire {
	if mmExpire.mock.inspectFuncExpire != nil {
		mmExpire.mock.t.Fatalf("Inspect function is already set for CacheMock.Expire")
	}

	mmExpire.mock.inspectFuncExpire = f

	return mmExpire
}

// Return sets up results that will be returned by Cache.Expire
func (mmExpire *mCacheMockExpire) Return(err error) *CacheMock {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	if mmExpire.defaultExpectation == nil {
		mmExpire.defaultExpectation = &CacheMockExpireExpectation{mock: mmExpire.mock}
	}
	mmExpire.defaultExpectation.results = &CacheMockExpireResults{err}
	return mmExpire.mock
}

// Set uses given function f to mock the Cache.Expire method
func (mmExpire *mCacheMockExpire) Set(f func(ctx context.Context, key string, expiration time.Duration) (err error)) *CacheMock {
	if mmExpire.defaultExpectation != nil {
		mmExpire.mock.t.Fatalf("Default expectation is already set for the Cache.Expire method")
	}

	if len(mmExpire.expectations) > 0 {
		mmExpire.mock.t.Fatalf("Some expectations are already set for the Cache.Expire method")
	}

	mmExpire.mock.funcExpire = f
	return mmExpire.mock
}

// When sets expectation for the Cache.Expire which will trigger the result defined by the following
// Then helper
func (mmExpire *mCacheMockExpire) When(ctx context.Context, key string, expiration time.Duration) *CacheMockExpireExpectation {
	if mmExpire.mock.funcExpire != nil {
		mmExpire.mock.t.Fatalf("CacheMock.Expire mock is already set by Set")
	}

	expectation := &CacheMockExpireExpectation{
		mock:   mmExpire.mock,
		params: &CacheMockExpireParams{ctx, key, expiration},
	}
	mmExpire.expectations = append(mmExpire.expectations, expectation)
	return expectation
}

// Then sets up Cache.Expire return parameters for the expectation previously defined by the When method
func (e *CacheMockExpireExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockExpireResults{err}
	return e.mock
}

// Times sets number of times Cache.Expire should be invoked
func (mmExpire *mCacheMockExpire) Times(n uint64) *mCacheMockExpire {
	if n == 0 {
		mmExpire.mock.t.Fatalf("Times of CacheMock.Expire mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpire.expectedInvocations, n)
	return mmExpire
}

func (mmExpire *mCacheMockExpire) invocationsDone() bool {
	if len(mmExpire.expectations) == 0 && mmExpire.defaultExpectation == nil && mmExpire.mock.funcExpire == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpire.mock.afterExpireCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpire.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Expire implements cache.Cache
func (mmExpire *CacheMock) Expire(ctx context.Context, key string, expiration time.Duration) (err error) {
	mm_atomic.AddUint64(&mmExpire.beforeExpireCounter, 1)
	defer mm_atomic.AddUint64(&mmExpire.afterExpireCounter, 1)

	if mmExpire.inspectFuncExpire != nil {
		mmExpire.inspectFuncExpire(ctx, key, expiration)
	}

	mm_params := CacheMockExpireParams{ctx, key, expiration}

	// Record call args
	mmExpire.ExpireMock.mutex.Lock()
	mmExpire.ExpireMock.callArgs = append(mmExpire.ExpireMock.callArgs, &mm_params)
	mmExpire.ExpireMock.mutex.Unlock()

	for _, e := range mmExpire.ExpireMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmExpire.ExpireMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpire.ExpireMock.defaultExpectation.Counter, 1)
		mm_want := mmExpire.ExpireMock.defaultExpectation.params
		mm_want_ptrs := mmExpire.ExpireMock.defaultExpectation.paramPtrs

		mm_got := CacheMockExpireParams{ctx, key, expiration}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmExpire.t.Errorf("CacheMock.Expire got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmExpire.t.Errorf("CacheMock.Expire got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.expiration != nil && !minimock.Equal(*mm_want_ptrs.expiration, mm_got.expiration) {
				mmExpire.t.Errorf("CacheMock.Expire got unexpected parameter expiration, want: %#v, got: %#v%s\n", *mm_want_ptrs.expiration, mm_got.expiration, minimock.Diff(*mm_want_ptrs.expiration, mm_got.expiration))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpire.t.Errorf("CacheMock.Expire got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExpire.ExpireMock.defaultExpectation.results
		if mm_results == nil {
			mmExpire.t.Fatal("No results are set for the CacheMock.Expire")
		}
		return (*mm_results).err
	}
	if mmExpire.funcExpire != nil {
		return mmExpire.funcExpire(ctx, key, expiration)
	}
	mmExpire.t.Fatalf("Unexpected call to CacheMock.Expire. %v %v %v", ctx, key, expiration)
	return
}

// ExpireAfterCounter returns a count of finished CacheMock.Expire invocations
func (mmExpire *CacheMock) ExpireAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.afterExpireCounter)
}

// ExpireBeforeCounter returns a count of CacheMock.Expire invocations
func (mmExpire *CacheMock) ExpireBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpire.beforeExpireCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Expire.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpire *mCacheMockExpire) Calls() []*CacheMockExpireParams {
	mmExpire.mutex.RLock()

	argCopy := make([]*CacheMockExpireParams, len(mmExpire.callArgs))
	copy(argCopy, mmExpire.callArgs)

	mmExpire.mutex.RUnlock()

	return argCopy
}

// MinimockExpireDone returns true if the count of the Expire invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockExpireDone() bool {
	if m.ExpireMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireMock.invocationsDone()
}

// MinimockExpireInspect logs each unmet expectation
func (m *CacheMock) MinimockExpireInspect() {
	for _, e := range m.ExpireMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Expire with params: %#v", *e.params)
		}
	}

	afterExpireCounter := mm_atomic.LoadUint64(&m.afterExpireCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireMock.defaultExpectation != nil && afterExpireCounter < 1 {
		if m.ExpireMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Expire")
		} else {
			m.t.Errorf("Expected call to CacheMock.Expire with params: %#v", *m.ExpireMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpire != nil && afterExpireCounter < 1 {
		m.t.Error("Expected call to CacheMock.Expire")
	}

	if !m.ExpireMock.invocationsDone() && afterExpireCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Expire but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireMock.expectedInvocations), afterExpireCounter)
	}
}

type mCacheMockGet struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockGetExpectation
	expectations       []*CacheMockGetExpectation

	callArgs []*CacheMockGetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockGetExpectation specifies expectation struct of the Cache.Get
type CacheMockGetExpectation struct {
	mock      *CacheMock
	params    *CacheMockGetParams
	paramPtrs *CacheMockGetParamPtrs
	results   *CacheMockGetResults
	Counter   uint64
}

// CacheMockGetParams contains parameters of the Cache.Get
type CacheMockGetParams struct {
	ctx context.Context
	key string
	in  interface{}
}

// CacheMockGetParamPtrs contains pointers to parameters of the Cache.Get
type CacheMockGetParamPtrs struct {
	ctx *context.Context
	key *string
	in  *interface{}
}

// CacheMockGetResults contains results of the Cache.Get
type CacheMockGetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mCacheMockGet) Optional() *mCacheMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Cache.Get
func (mmGet *mCacheMockGet) Expect(ctx context.Context, key string, in interface{}) *mCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &CacheMockGetParams{ctx, key, in}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Cache.Get
func (mmGet *mCacheMockGet) ExpectCtxParam1(ctx context.Context) *mCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGet
}

// ExpectKeyParam2 sets up expected param key for Cache.Get
func (mmGet *mCacheMockGet) ExpectKeyParam2(key string) *mCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.key = &key

	return mmGet
}

// ExpectInParam3 sets up expected param in for Cache.Get
func (mmGet *mCacheMockGet) ExpectInParam3(in interface{}) *mCacheMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CacheMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.in = &in

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Cache.Get
func (mmGet *mCacheMockGet) Inspect(f func(ctx context.Context, key string, in interface{})) *mCacheMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for CacheMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Cache.Get
func (mmGet *mCacheMockGet) Return(err error) *CacheMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CacheMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &CacheMockGetResults{err}
	return mmGet.mock
}

// Set uses given function f to mock the Cache.Get method
func (mmGet *mCacheMockGet) Set(f func(ctx context.Context, key string, in interface{}) (err error)) *CacheMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Cache.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Cache.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Cache.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mCacheMockGet) When(ctx context.Context, key string, in interface{}) *CacheMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CacheMock.Get mock is already set by Set")
	}

	expectation := &CacheMockGetExpectation{
		mock:   mmGet.mock,
		params: &CacheMockGetParams{ctx, key, in},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Cache.Get return parameters for the expectation previously defined by the When method
func (e *CacheMockGetExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockGetResults{err}
	return e.mock
}

// Times sets number of times Cache.Get should be invoked
func (mmGet *mCacheMockGet) Times(n uint64) *mCacheMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of CacheMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	return mmGet
}

func (mmGet *mCacheMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements cache.Cache
func (mmGet *CacheMock) Get(ctx context.Context, key string, in interface{}) (err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key, in)
	}

	mm_params := CacheMockGetParams{ctx, key, in}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := CacheMockGetParams{ctx, key, in}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("CacheMock.Get got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmGet.t.Errorf("CacheMock.Get got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmGet.t.Errorf("CacheMock.Get got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("CacheMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the CacheMock.Get")
		}
		return (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key, in)
	}
	mmGet.t.Fatalf("Unexpected call to CacheMock.Get. %v %v %v", ctx, key, in)
	return
}

// GetAfterCounter returns a count of finished CacheMock.Get invocations
func (mmGet *CacheMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of CacheMock.Get invocations
func (mmGet *CacheMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mCacheMockGet) Calls() []*CacheMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*CacheMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *CacheMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Get with params: %#v", *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Get")
		} else {
			m.t.Errorf("Expected call to CacheMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Error("Expected call to CacheMock.Get")
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Get but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), afterGetCounter)
	}
}

type mCacheMockHDel struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockHDelExpectation
	expectations       []*CacheMockHDelExpectation

	callArgs []*CacheMockHDelParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockHDelExpectation specifies expectation struct of the Cache.HDel
type CacheMockHDelExpectation struct {
	mock      *CacheMock
	params    *CacheMockHDelParams
	paramPtrs *CacheMockHDelParamPtrs
	results   *CacheMockHDelResults
	Counter   uint64
}

// CacheMockHDelParams contains parameters of the Cache.HDel
type CacheMockHDelParams struct {
	ctx   context.Context
	key   string
	field []string
}

// CacheMockHDelParamPtrs contains pointers to parameters of the Cache.HDel
type CacheMockHDelParamPtrs struct {
	ctx   *context.Context
	key   *string
	field *[]string
}

// CacheMockHDelResults contains results of the Cache.HDel
type CacheMockHDelResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHDel *mCacheMockHDel) Optional() *mCacheMockHDel {
	mmHDel.optional = true
	return mmHDel
}

// Expect sets up expected params for Cache.HDel
func (mmHDel *mCacheMockHDel) Expect(ctx context.Context, key string, field ...string) *mCacheMockHDel {
	if mmHDel.mock.funcHDel != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Set")
	}

	if mmHDel.defaultExpectation == nil {
		mmHDel.defaultExpectation = &CacheMockHDelExpectation{}
	}

	if mmHDel.defaultExpectation.paramPtrs != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by ExpectParams functions")
	}

	mmHDel.defaultExpectation.params = &CacheMockHDelParams{ctx, key, field}
	for _, e := range mmHDel.expectations {
		if minimock.Equal(e.params, mmHDel.defaultExpectation.params) {
			mmHDel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHDel.defaultExpectation.params)
		}
	}

	return mmHDel
}

// ExpectCtxParam1 sets up expected param ctx for Cache.HDel
func (mmHDel *mCacheMockHDel) ExpectCtxParam1(ctx context.Context) *mCacheMockHDel {
	if mmHDel.mock.funcHDel != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Set")
	}

	if mmHDel.defaultExpectation == nil {
		mmHDel.defaultExpectation = &CacheMockHDelExpectation{}
	}

	if mmHDel.defaultExpectation.params != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Expect")
	}

	if mmHDel.defaultExpectation.paramPtrs == nil {
		mmHDel.defaultExpectation.paramPtrs = &CacheMockHDelParamPtrs{}
	}
	mmHDel.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHDel
}

// ExpectKeyParam2 sets up expected param key for Cache.HDel
func (mmHDel *mCacheMockHDel) ExpectKeyParam2(key string) *mCacheMockHDel {
	if mmHDel.mock.funcHDel != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Set")
	}

	if mmHDel.defaultExpectation == nil {
		mmHDel.defaultExpectation = &CacheMockHDelExpectation{}
	}

	if mmHDel.defaultExpectation.params != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Expect")
	}

	if mmHDel.defaultExpectation.paramPtrs == nil {
		mmHDel.defaultExpectation.paramPtrs = &CacheMockHDelParamPtrs{}
	}
	mmHDel.defaultExpectation.paramPtrs.key = &key

	return mmHDel
}

// ExpectFieldParam3 sets up expected param field for Cache.HDel
func (mmHDel *mCacheMockHDel) ExpectFieldParam3(field ...string) *mCacheMockHDel {
	if mmHDel.mock.funcHDel != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Set")
	}

	if mmHDel.defaultExpectation == nil {
		mmHDel.defaultExpectation = &CacheMockHDelExpectation{}
	}

	if mmHDel.defaultExpectation.params != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Expect")
	}

	if mmHDel.defaultExpectation.paramPtrs == nil {
		mmHDel.defaultExpectation.paramPtrs = &CacheMockHDelParamPtrs{}
	}
	mmHDel.defaultExpectation.paramPtrs.field = &field

	return mmHDel
}

// Inspect accepts an inspector function that has same arguments as the Cache.HDel
func (mmHDel *mCacheMockHDel) Inspect(f func(ctx context.Context, key string, field ...string)) *mCacheMockHDel {
	if mmHDel.mock.inspectFuncHDel != nil {
		mmHDel.mock.t.Fatalf("Inspect function is already set for CacheMock.HDel")
	}

	mmHDel.mock.inspectFuncHDel = f

	return mmHDel
}

// Return sets up results that will be returned by Cache.HDel
func (mmHDel *mCacheMockHDel) Return(err error) *CacheMock {
	if mmHDel.mock.funcHDel != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Set")
	}

	if mmHDel.defaultExpectation == nil {
		mmHDel.defaultExpectation = &CacheMockHDelExpectation{mock: mmHDel.mock}
	}
	mmHDel.defaultExpectation.results = &CacheMockHDelResults{err}
	return mmHDel.mock
}

// Set uses given function f to mock the Cache.HDel method
func (mmHDel *mCacheMockHDel) Set(f func(ctx context.Context, key string, field ...string) (err error)) *CacheMock {
	if mmHDel.defaultExpectation != nil {
		mmHDel.mock.t.Fatalf("Default expectation is already set for the Cache.HDel method")
	}

	if len(mmHDel.expectations) > 0 {
		mmHDel.mock.t.Fatalf("Some expectations are already set for the Cache.HDel method")
	}

	mmHDel.mock.funcHDel = f
	return mmHDel.mock
}

// When sets expectation for the Cache.HDel which will trigger the result defined by the following
// Then helper
func (mmHDel *mCacheMockHDel) When(ctx context.Context, key string, field ...string) *CacheMockHDelExpectation {
	if mmHDel.mock.funcHDel != nil {
		mmHDel.mock.t.Fatalf("CacheMock.HDel mock is already set by Set")
	}

	expectation := &CacheMockHDelExpectation{
		mock:   mmHDel.mock,
		params: &CacheMockHDelParams{ctx, key, field},
	}
	mmHDel.expectations = append(mmHDel.expectations, expectation)
	return expectation
}

// Then sets up Cache.HDel return parameters for the expectation previously defined by the When method
func (e *CacheMockHDelExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockHDelResults{err}
	return e.mock
}

// Times sets number of times Cache.HDel should be invoked
func (mmHDel *mCacheMockHDel) Times(n uint64) *mCacheMockHDel {
	if n == 0 {
		mmHDel.mock.t.Fatalf("Times of CacheMock.HDel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHDel.expectedInvocations, n)
	return mmHDel
}

func (mmHDel *mCacheMockHDel) invocationsDone() bool {
	if len(mmHDel.expectations) == 0 && mmHDel.defaultExpectation == nil && mmHDel.mock.funcHDel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHDel.mock.afterHDelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHDel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HDel implements cache.Cache
func (mmHDel *CacheMock) HDel(ctx context.Context, key string, field ...string) (err error) {
	mm_atomic.AddUint64(&mmHDel.beforeHDelCounter, 1)
	defer mm_atomic.AddUint64(&mmHDel.afterHDelCounter, 1)

	if mmHDel.inspectFuncHDel != nil {
		mmHDel.inspectFuncHDel(ctx, key, field...)
	}

	mm_params := CacheMockHDelParams{ctx, key, field}

	// Record call args
	mmHDel.HDelMock.mutex.Lock()
	mmHDel.HDelMock.callArgs = append(mmHDel.HDelMock.callArgs, &mm_params)
	mmHDel.HDelMock.mutex.Unlock()

	for _, e := range mmHDel.HDelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHDel.HDelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHDel.HDelMock.defaultExpectation.Counter, 1)
		mm_want := mmHDel.HDelMock.defaultExpectation.params
		mm_want_ptrs := mmHDel.HDelMock.defaultExpectation.paramPtrs

		mm_got := CacheMockHDelParams{ctx, key, field}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHDel.t.Errorf("CacheMock.HDel got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHDel.t.Errorf("CacheMock.HDel got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.field != nil && !minimock.Equal(*mm_want_ptrs.field, mm_got.field) {
				mmHDel.t.Errorf("CacheMock.HDel got unexpected parameter field, want: %#v, got: %#v%s\n", *mm_want_ptrs.field, mm_got.field, minimock.Diff(*mm_want_ptrs.field, mm_got.field))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHDel.t.Errorf("CacheMock.HDel got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHDel.HDelMock.defaultExpectation.results
		if mm_results == nil {
			mmHDel.t.Fatal("No results are set for the CacheMock.HDel")
		}
		return (*mm_results).err
	}
	if mmHDel.funcHDel != nil {
		return mmHDel.funcHDel(ctx, key, field...)
	}
	mmHDel.t.Fatalf("Unexpected call to CacheMock.HDel. %v %v %v", ctx, key, field)
	return
}

// HDelAfterCounter returns a count of finished CacheMock.HDel invocations
func (mmHDel *CacheMock) HDelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHDel.afterHDelCounter)
}

// HDelBeforeCounter returns a count of CacheMock.HDel invocations
func (mmHDel *CacheMock) HDelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHDel.beforeHDelCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.HDel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHDel *mCacheMockHDel) Calls() []*CacheMockHDelParams {
	mmHDel.mutex.RLock()

	argCopy := make([]*CacheMockHDelParams, len(mmHDel.callArgs))
	copy(argCopy, mmHDel.callArgs)

	mmHDel.mutex.RUnlock()

	return argCopy
}

// MinimockHDelDone returns true if the count of the HDel invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockHDelDone() bool {
	if m.HDelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HDelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HDelMock.invocationsDone()
}

// MinimockHDelInspect logs each unmet expectation
func (m *CacheMock) MinimockHDelInspect() {
	for _, e := range m.HDelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.HDel with params: %#v", *e.params)
		}
	}

	afterHDelCounter := mm_atomic.LoadUint64(&m.afterHDelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HDelMock.defaultExpectation != nil && afterHDelCounter < 1 {
		if m.HDelMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.HDel")
		} else {
			m.t.Errorf("Expected call to CacheMock.HDel with params: %#v", *m.HDelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHDel != nil && afterHDelCounter < 1 {
		m.t.Error("Expected call to CacheMock.HDel")
	}

	if !m.HDelMock.invocationsDone() && afterHDelCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.HDel but found %d calls",
			mm_atomic.LoadUint64(&m.HDelMock.expectedInvocations), afterHDelCounter)
	}
}

type mCacheMockHGet struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockHGetExpectation
	expectations       []*CacheMockHGetExpectation

	callArgs []*CacheMockHGetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockHGetExpectation specifies expectation struct of the Cache.HGet
type CacheMockHGetExpectation struct {
	mock      *CacheMock
	params    *CacheMockHGetParams
	paramPtrs *CacheMockHGetParamPtrs
	results   *CacheMockHGetResults
	Counter   uint64
}

// CacheMockHGetParams contains parameters of the Cache.HGet
type CacheMockHGetParams struct {
	ctx   context.Context
	key   string
	field string
	in    interface{}
}

// CacheMockHGetParamPtrs contains pointers to parameters of the Cache.HGet
type CacheMockHGetParamPtrs struct {
	ctx   *context.Context
	key   *string
	field *string
	in    *interface{}
}

// CacheMockHGetResults contains results of the Cache.HGet
type CacheMockHGetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHGet *mCacheMockHGet) Optional() *mCacheMockHGet {
	mmHGet.optional = true
	return mmHGet
}

// Expect sets up expected params for Cache.HGet
func (mmHGet *mCacheMockHGet) Expect(ctx context.Context, key string, field string, in interface{}) *mCacheMockHGet {
	if mmHGet.mock.funcHGet != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Set")
	}

	if mmHGet.defaultExpectation == nil {
		mmHGet.defaultExpectation = &CacheMockHGetExpectation{}
	}

	if mmHGet.defaultExpectation.paramPtrs != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by ExpectParams functions")
	}

	mmHGet.defaultExpectation.params = &CacheMockHGetParams{ctx, key, field, in}
	for _, e := range mmHGet.expectations {
		if minimock.Equal(e.params, mmHGet.defaultExpectation.params) {
			mmHGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHGet.defaultExpectation.params)
		}
	}

	return mmHGet
}

// ExpectCtxParam1 sets up expected param ctx for Cache.HGet
func (mmHGet *mCacheMockHGet) ExpectCtxParam1(ctx context.Context) *mCacheMockHGet {
	if mmHGet.mock.funcHGet != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Set")
	}

	if mmHGet.defaultExpectation == nil {
		mmHGet.defaultExpectation = &CacheMockHGetExpectation{}
	}

	if mmHGet.defaultExpectation.params != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Expect")
	}

	if mmHGet.defaultExpectation.paramPtrs == nil {
		mmHGet.defaultExpectation.paramPtrs = &CacheMockHGetParamPtrs{}
	}
	mmHGet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHGet
}

// ExpectKeyParam2 sets up expected param key for Cache.HGet
func (mmHGet *mCacheMockHGet) ExpectKeyParam2(key string) *mCacheMockHGet {
	if mmHGet.mock.funcHGet != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Set")
	}

	if mmHGet.defaultExpectation == nil {
		mmHGet.defaultExpectation = &CacheMockHGetExpectation{}
	}

	if mmHGet.defaultExpectation.params != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Expect")
	}

	if mmHGet.defaultExpectation.paramPtrs == nil {
		mmHGet.defaultExpectation.paramPtrs = &CacheMockHGetParamPtrs{}
	}
	mmHGet.defaultExpectation.paramPtrs.key = &key

	return mmHGet
}

// ExpectFieldParam3 sets up expected param field for Cache.HGet
func (mmHGet *mCacheMockHGet) ExpectFieldParam3(field string) *mCacheMockHGet {
	if mmHGet.mock.funcHGet != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Set")
	}

	if mmHGet.defaultExpectation == nil {
		mmHGet.defaultExpectation = &CacheMockHGetExpectation{}
	}

	if mmHGet.defaultExpectation.params != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Expect")
	}

	if mmHGet.defaultExpectation.paramPtrs == nil {
		mmHGet.defaultExpectation.paramPtrs = &CacheMockHGetParamPtrs{}
	}
	mmHGet.defaultExpectation.paramPtrs.field = &field

	return mmHGet
}

// ExpectInParam4 sets up expected param in for Cache.HGet
func (mmHGet *mCacheMockHGet) ExpectInParam4(in interface{}) *mCacheMockHGet {
	if mmHGet.mock.funcHGet != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Set")
	}

	if mmHGet.defaultExpectation == nil {
		mmHGet.defaultExpectation = &CacheMockHGetExpectation{}
	}

	if mmHGet.defaultExpectation.params != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Expect")
	}

	if mmHGet.defaultExpectation.paramPtrs == nil {
		mmHGet.defaultExpectation.paramPtrs = &CacheMockHGetParamPtrs{}
	}
	mmHGet.defaultExpectation.paramPtrs.in = &in

	return mmHGet
}

// Inspect accepts an inspector function that has same arguments as the Cache.HGet
func (mmHGet *mCacheMockHGet) Inspect(f func(ctx context.Context, key string, field string, in interface{})) *mCacheMockHGet {
	if mmHGet.mock.inspectFuncHGet != nil {
		mmHGet.mock.t.Fatalf("Inspect function is already set for CacheMock.HGet")
	}

	mmHGet.mock.inspectFuncHGet = f

	return mmHGet
}

// Return sets up results that will be returned by Cache.HGet
func (mmHGet *mCacheMockHGet) Return(err error) *CacheMock {
	if mmHGet.mock.funcHGet != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Set")
	}

	if mmHGet.defaultExpectation == nil {
		mmHGet.defaultExpectation = &CacheMockHGetExpectation{mock: mmHGet.mock}
	}
	mmHGet.defaultExpectation.results = &CacheMockHGetResults{err}
	return mmHGet.mock
}

// Set uses given function f to mock the Cache.HGet method
func (mmHGet *mCacheMockHGet) Set(f func(ctx context.Context, key string, field string, in interface{}) (err error)) *CacheMock {
	if mmHGet.defaultExpectation != nil {
		mmHGet.mock.t.Fatalf("Default expectation is already set for the Cache.HGet method")
	}

	if len(mmHGet.expectations) > 0 {
		mmHGet.mock.t.Fatalf("Some expectations are already set for the Cache.HGet method")
	}

	mmHGet.mock.funcHGet = f
	return mmHGet.mock
}

// When sets expectation for the Cache.HGet which will trigger the result defined by the following
// Then helper
func (mmHGet *mCacheMockHGet) When(ctx context.Context, key string, field string, in interface{}) *CacheMockHGetExpectation {
	if mmHGet.mock.funcHGet != nil {
		mmHGet.mock.t.Fatalf("CacheMock.HGet mock is already set by Set")
	}

	expectation := &CacheMockHGetExpectation{
		mock:   mmHGet.mock,
		params: &CacheMockHGetParams{ctx, key, field, in},
	}
	mmHGet.expectations = append(mmHGet.expectations, expectation)
	return expectation
}

// Then sets up Cache.HGet return parameters for the expectation previously defined by the When method
func (e *CacheMockHGetExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockHGetResults{err}
	return e.mock
}

// Times sets number of times Cache.HGet should be invoked
func (mmHGet *mCacheMockHGet) Times(n uint64) *mCacheMockHGet {
	if n == 0 {
		mmHGet.mock.t.Fatalf("Times of CacheMock.HGet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHGet.expectedInvocations, n)
	return mmHGet
}

func (mmHGet *mCacheMockHGet) invocationsDone() bool {
	if len(mmHGet.expectations) == 0 && mmHGet.defaultExpectation == nil && mmHGet.mock.funcHGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHGet.mock.afterHGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HGet implements cache.Cache
func (mmHGet *CacheMock) HGet(ctx context.Context, key string, field string, in interface{}) (err error) {
	mm_atomic.AddUint64(&mmHGet.beforeHGetCounter, 1)
	defer mm_atomic.AddUint64(&mmHGet.afterHGetCounter, 1)

	if mmHGet.inspectFuncHGet != nil {
		mmHGet.inspectFuncHGet(ctx, key, field, in)
	}

	mm_params := CacheMockHGetParams{ctx, key, field, in}

	// Record call args
	mmHGet.HGetMock.mutex.Lock()
	mmHGet.HGetMock.callArgs = append(mmHGet.HGetMock.callArgs, &mm_params)
	mmHGet.HGetMock.mutex.Unlock()

	for _, e := range mmHGet.HGetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHGet.HGetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHGet.HGetMock.defaultExpectation.Counter, 1)
		mm_want := mmHGet.HGetMock.defaultExpectation.params
		mm_want_ptrs := mmHGet.HGetMock.defaultExpectation.paramPtrs

		mm_got := CacheMockHGetParams{ctx, key, field, in}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHGet.t.Errorf("CacheMock.HGet got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHGet.t.Errorf("CacheMock.HGet got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.field != nil && !minimock.Equal(*mm_want_ptrs.field, mm_got.field) {
				mmHGet.t.Errorf("CacheMock.HGet got unexpected parameter field, want: %#v, got: %#v%s\n", *mm_want_ptrs.field, mm_got.field, minimock.Diff(*mm_want_ptrs.field, mm_got.field))
			}

			if mm_want_ptrs.in != nil && !minimock.Equal(*mm_want_ptrs.in, mm_got.in) {
				mmHGet.t.Errorf("CacheMock.HGet got unexpected parameter in, want: %#v, got: %#v%s\n", *mm_want_ptrs.in, mm_got.in, minimock.Diff(*mm_want_ptrs.in, mm_got.in))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHGet.t.Errorf("CacheMock.HGet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHGet.HGetMock.defaultExpectation.results
		if mm_results == nil {
			mmHGet.t.Fatal("No results are set for the CacheMock.HGet")
		}
		return (*mm_results).err
	}
	if mmHGet.funcHGet != nil {
		return mmHGet.funcHGet(ctx, key, field, in)
	}
	mmHGet.t.Fatalf("Unexpected call to CacheMock.HGet. %v %v %v %v", ctx, key, field, in)
	return
}

// HGetAfterCounter returns a count of finished CacheMock.HGet invocations
func (mmHGet *CacheMock) HGetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGet.afterHGetCounter)
}

// HGetBeforeCounter returns a count of CacheMock.HGet invocations
func (mmHGet *CacheMock) HGetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHGet.beforeHGetCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.HGet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHGet *mCacheMockHGet) Calls() []*CacheMockHGetParams {
	mmHGet.mutex.RLock()

	argCopy := make([]*CacheMockHGetParams, len(mmHGet.callArgs))
	copy(argCopy, mmHGet.callArgs)

	mmHGet.mutex.RUnlock()

	return argCopy
}

// MinimockHGetDone returns true if the count of the HGet invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockHGetDone() bool {
	if m.HGetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HGetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HGetMock.invocationsDone()
}

// MinimockHGetInspect logs each unmet expectation
func (m *CacheMock) MinimockHGetInspect() {
	for _, e := range m.HGetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.HGet with params: %#v", *e.params)
		}
	}

	afterHGetCounter := mm_atomic.LoadUint64(&m.afterHGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HGetMock.defaultExpectation != nil && afterHGetCounter < 1 {
		if m.HGetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.HGet")
		} else {
			m.t.Errorf("Expected call to CacheMock.HGet with params: %#v", *m.HGetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHGet != nil && afterHGetCounter < 1 {
		m.t.Error("Expected call to CacheMock.HGet")
	}

	if !m.HGetMock.invocationsDone() && afterHGetCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.HGet but found %d calls",
			mm_atomic.LoadUint64(&m.HGetMock.expectedInvocations), afterHGetCounter)
	}
}

type mCacheMockHSet struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockHSetExpectation
	expectations       []*CacheMockHSetExpectation

	callArgs []*CacheMockHSetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockHSetExpectation specifies expectation struct of the Cache.HSet
type CacheMockHSetExpectation struct {
	mock      *CacheMock
	params    *CacheMockHSetParams
	paramPtrs *CacheMockHSetParamPtrs
	results   *CacheMockHSetResults
	Counter   uint64
}

// CacheMockHSetParams contains parameters of the Cache.HSet
type CacheMockHSetParams struct {
	ctx   context.Context
	key   string
	field string
	value interface{}
}

// CacheMockHSetParamPtrs contains pointers to parameters of the Cache.HSet
type CacheMockHSetParamPtrs struct {
	ctx   *context.Context
	key   *string
	field *string
	value *interface{}
}

// CacheMockHSetResults contains results of the Cache.HSet
type CacheMockHSetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHSet *mCacheMockHSet) Optional() *mCacheMockHSet {
	mmHSet.optional = true
	return mmHSet
}

// Expect sets up expected params for Cache.HSet
func (mmHSet *mCacheMockHSet) Expect(ctx context.Context, key string, field string, value interface{}) *mCacheMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &CacheMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.paramPtrs != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by ExpectParams functions")
	}

	mmHSet.defaultExpectation.params = &CacheMockHSetParams{ctx, key, field, value}
	for _, e := range mmHSet.expectations {
		if minimock.Equal(e.params, mmHSet.defaultExpectation.params) {
			mmHSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHSet.defaultExpectation.params)
		}
	}

	return mmHSet
}

// ExpectCtxParam1 sets up expected param ctx for Cache.HSet
func (mmHSet *mCacheMockHSet) ExpectCtxParam1(ctx context.Context) *mCacheMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &CacheMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.params != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Expect")
	}

	if mmHSet.defaultExpectation.paramPtrs == nil {
		mmHSet.defaultExpectation.paramPtrs = &CacheMockHSetParamPtrs{}
	}
	mmHSet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmHSet
}

// ExpectKeyParam2 sets up expected param key for Cache.HSet
func (mmHSet *mCacheMockHSet) ExpectKeyParam2(key string) *mCacheMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &CacheMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.params != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Expect")
	}

	if mmHSet.defaultExpectation.paramPtrs == nil {
		mmHSet.defaultExpectation.paramPtrs = &CacheMockHSetParamPtrs{}
	}
	mmHSet.defaultExpectation.paramPtrs.key = &key

	return mmHSet
}

// ExpectFieldParam3 sets up expected param field for Cache.HSet
func (mmHSet *mCacheMockHSet) ExpectFieldParam3(field string) *mCacheMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &CacheMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.params != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Expect")
	}

	if mmHSet.defaultExpectation.paramPtrs == nil {
		mmHSet.defaultExpectation.paramPtrs = &CacheMockHSetParamPtrs{}
	}
	mmHSet.defaultExpectation.paramPtrs.field = &field

	return mmHSet
}

// ExpectValueParam4 sets up expected param value for Cache.HSet
func (mmHSet *mCacheMockHSet) ExpectValueParam4(value interface{}) *mCacheMockHSet {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &CacheMockHSetExpectation{}
	}

	if mmHSet.defaultExpectation.params != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Expect")
	}

	if mmHSet.defaultExpectation.paramPtrs == nil {
		mmHSet.defaultExpectation.paramPtrs = &CacheMockHSetParamPtrs{}
	}
	mmHSet.defaultExpectation.paramPtrs.value = &value

	return mmHSet
}

// Inspect accepts an inspector function that has same arguments as the Cache.HSet
func (mmHSet *mCacheMockHSet) Inspect(f func(ctx context.Context, key string, field string, value interface{})) *mCacheMockHSet {
	if mmHSet.mock.inspectFuncHSet != nil {
		mmHSet.mock.t.Fatalf("Inspect function is already set for CacheMock.HSet")
	}

	mmHSet.mock.inspectFuncHSet = f

	return mmHSet
}

// Return sets up results that will be returned by Cache.HSet
func (mmHSet *mCacheMockHSet) Return(err error) *CacheMock {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Set")
	}

	if mmHSet.defaultExpectation == nil {
		mmHSet.defaultExpectation = &CacheMockHSetExpectation{mock: mmHSet.mock}
	}
	mmHSet.defaultExpectation.results = &CacheMockHSetResults{err}
	return mmHSet.mock
}

// Set uses given function f to mock the Cache.HSet method
func (mmHSet *mCacheMockHSet) Set(f func(ctx context.Context, key string, field string, value interface{}) (err error)) *CacheMock {
	if mmHSet.defaultExpectation != nil {
		mmHSet.mock.t.Fatalf("Default expectation is already set for the Cache.HSet method")
	}

	if len(mmHSet.expectations) > 0 {
		mmHSet.mock.t.Fatalf("Some expectations are already set for the Cache.HSet method")
	}

	mmHSet.mock.funcHSet = f
	return mmHSet.mock
}

// When sets expectation for the Cache.HSet which will trigger the result defined by the following
// Then helper
func (mmHSet *mCacheMockHSet) When(ctx context.Context, key string, field string, value interface{}) *CacheMockHSetExpectation {
	if mmHSet.mock.funcHSet != nil {
		mmHSet.mock.t.Fatalf("CacheMock.HSet mock is already set by Set")
	}

	expectation := &CacheMockHSetExpectation{
		mock:   mmHSet.mock,
		params: &CacheMockHSetParams{ctx, key, field, value},
	}
	mmHSet.expectations = append(mmHSet.expectations, expectation)
	return expectation
}

// Then sets up Cache.HSet return parameters for the expectation previously defined by the When method
func (e *CacheMockHSetExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockHSetResults{err}
	return e.mock
}

// Times sets number of times Cache.HSet should be invoked
func (mmHSet *mCacheMockHSet) Times(n uint64) *mCacheMockHSet {
	if n == 0 {
		mmHSet.mock.t.Fatalf("Times of CacheMock.HSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHSet.expectedInvocations, n)
	return mmHSet
}

func (mmHSet *mCacheMockHSet) invocationsDone() bool {
	if len(mmHSet.expectations) == 0 && mmHSet.defaultExpectation == nil && mmHSet.mock.funcHSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHSet.mock.afterHSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HSet implements cache.Cache
func (mmHSet *CacheMock) HSet(ctx context.Context, key string, field string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmHSet.beforeHSetCounter, 1)
	defer mm_atomic.AddUint64(&mmHSet.afterHSetCounter, 1)

	if mmHSet.inspectFuncHSet != nil {
		mmHSet.inspectFuncHSet(ctx, key, field, value)
	}

	mm_params := CacheMockHSetParams{ctx, key, field, value}

	// Record call args
	mmHSet.HSetMock.mutex.Lock()
	mmHSet.HSetMock.callArgs = append(mmHSet.HSetMock.callArgs, &mm_params)
	mmHSet.HSetMock.mutex.Unlock()

	for _, e := range mmHSet.HSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmHSet.HSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHSet.HSetMock.defaultExpectation.Counter, 1)
		mm_want := mmHSet.HSetMock.defaultExpectation.params
		mm_want_ptrs := mmHSet.HSetMock.defaultExpectation.paramPtrs

		mm_got := CacheMockHSetParams{ctx, key, field, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmHSet.t.Errorf("CacheMock.HSet got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmHSet.t.Errorf("CacheMock.HSet got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.field != nil && !minimock.Equal(*mm_want_ptrs.field, mm_got.field) {
				mmHSet.t.Errorf("CacheMock.HSet got unexpected parameter field, want: %#v, got: %#v%s\n", *mm_want_ptrs.field, mm_got.field, minimock.Diff(*mm_want_ptrs.field, mm_got.field))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmHSet.t.Errorf("CacheMock.HSet got unexpected parameter value, want: %#v, got: %#v%s\n", *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHSet.t.Errorf("CacheMock.HSet got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHSet.HSetMock.defaultExpectation.results
		if mm_results == nil {
			mmHSet.t.Fatal("No results are set for the CacheMock.HSet")
		}
		return (*mm_results).err
	}
	if mmHSet.funcHSet != nil {
		return mmHSet.funcHSet(ctx, key, field, value)
	}
	mmHSet.t.Fatalf("Unexpected call to CacheMock.HSet. %v %v %v %v", ctx, key, field, value)
	return
}

// HSetAfterCounter returns a count of finished CacheMock.HSet invocations
func (mmHSet *CacheMock) HSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHSet.afterHSetCounter)
}

// HSetBeforeCounter returns a count of CacheMock.HSet invocations
func (mmHSet *CacheMock) HSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHSet.beforeHSetCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.HSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHSet *mCacheMockHSet) Calls() []*CacheMockHSetParams {
	mmHSet.mutex.RLock()

	argCopy := make([]*CacheMockHSetParams, len(mmHSet.callArgs))
	copy(argCopy, mmHSet.callArgs)

	mmHSet.mutex.RUnlock()

	return argCopy
}

// MinimockHSetDone returns true if the count of the HSet invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockHSetDone() bool {
	if m.HSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HSetMock.invocationsDone()
}

// MinimockHSetInspect logs each unmet expectation
func (m *CacheMock) MinimockHSetInspect() {
	for _, e := range m.HSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.HSet with params: %#v", *e.params)
		}
	}

	afterHSetCounter := mm_atomic.LoadUint64(&m.afterHSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HSetMock.defaultExpectation != nil && afterHSetCounter < 1 {
		if m.HSetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.HSet")
		} else {
			m.t.Errorf("Expected call to CacheMock.HSet with params: %#v", *m.HSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHSet != nil && afterHSetCounter < 1 {
		m.t.Error("Expected call to CacheMock.HSet")
	}

	if !m.HSetMock.invocationsDone() && afterHSetCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.HSet but found %d calls",
			mm_atomic.LoadUint64(&m.HSetMock.expectedInvocations), afterHSetCounter)
	}
}

type mCacheMockPing struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockPingExpectation
	expectations       []*CacheMockPingExpectation

	callArgs []*CacheMockPingParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockPingExpectation specifies expectation struct of the Cache.Ping
type CacheMockPingExpectation struct {
	mock      *CacheMock
	params    *CacheMockPingParams
	paramPtrs *CacheMockPingParamPtrs
	results   *CacheMockPingResults
	Counter   uint64
}

// CacheMockPingParams contains parameters of the Cache.Ping
type CacheMockPingParams struct {
	ctx context.Context
}

// CacheMockPingParamPtrs contains pointers to parameters of the Cache.Ping
type CacheMockPingParamPtrs struct {
	ctx *context.Context
}

// CacheMockPingResults contains results of the Cache.Ping
type CacheMockPingResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPing *mCacheMockPing) Optional() *mCacheMockPing {
	mmPing.optional = true
	return mmPing
}

// Expect sets up expected params for Cache.Ping
func (mmPing *mCacheMockPing) Expect(ctx context.Context) *mCacheMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &CacheMockPingExpectation{}
	}

	if mmPing.defaultExpectation.paramPtrs != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by ExpectParams functions")
	}

	mmPing.defaultExpectation.params = &CacheMockPingParams{ctx}
	for _, e := range mmPing.expectations {
		if minimock.Equal(e.params, mmPing.defaultExpectation.params) {
			mmPing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPing.defaultExpectation.params)
		}
	}

	return mmPing
}

// ExpectCtxParam1 sets up expected param ctx for Cache.Ping
func (mmPing *mCacheMockPing) ExpectCtxParam1(ctx context.Context) *mCacheMockPing {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &CacheMockPingExpectation{}
	}

	if mmPing.defaultExpectation.params != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Expect")
	}

	if mmPing.defaultExpectation.paramPtrs == nil {
		mmPing.defaultExpectation.paramPtrs = &CacheMockPingParamPtrs{}
	}
	mmPing.defaultExpectation.paramPtrs.ctx = &ctx

	return mmPing
}

// Inspect accepts an inspector function that has same arguments as the Cache.Ping
func (mmPing *mCacheMockPing) Inspect(f func(ctx context.Context)) *mCacheMockPing {
	if mmPing.mock.inspectFuncPing != nil {
		mmPing.mock.t.Fatalf("Inspect function is already set for CacheMock.Ping")
	}

	mmPing.mock.inspectFuncPing = f

	return mmPing
}

// Return sets up results that will be returned by Cache.Ping
func (mmPing *mCacheMockPing) Return(err error) *CacheMock {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Set")
	}

	if mmPing.defaultExpectation == nil {
		mmPing.defaultExpectation = &CacheMockPingExpectation{mock: mmPing.mock}
	}
	mmPing.defaultExpectation.results = &CacheMockPingResults{err}
	return mmPing.mock
}

// Set uses given function f to mock the Cache.Ping method
func (mmPing *mCacheMockPing) Set(f func(ctx context.Context) (err error)) *CacheMock {
	if mmPing.defaultExpectation != nil {
		mmPing.mock.t.Fatalf("Default expectation is already set for the Cache.Ping method")
	}

	if len(mmPing.expectations) > 0 {
		mmPing.mock.t.Fatalf("Some expectations are already set for the Cache.Ping method")
	}

	mmPing.mock.funcPing = f
	return mmPing.mock
}

// When sets expectation for the Cache.Ping which will trigger the result defined by the following
// Then helper
func (mmPing *mCacheMockPing) When(ctx context.Context) *CacheMockPingExpectation {
	if mmPing.mock.funcPing != nil {
		mmPing.mock.t.Fatalf("CacheMock.Ping mock is already set by Set")
	}

	expectation := &CacheMockPingExpectation{
		mock:   mmPing.mock,
		params: &CacheMockPingParams{ctx},
	}
	mmPing.expectations = append(mmPing.expectations, expectation)
	return expectation
}

// Then sets up Cache.Ping return parameters for the expectation previously defined by the When method
func (e *CacheMockPingExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockPingResults{err}
	return e.mock
}

// Times sets number of times Cache.Ping should be invoked
func (mmPing *mCacheMockPing) Times(n uint64) *mCacheMockPing {
	if n == 0 {
		mmPing.mock.t.Fatalf("Times of CacheMock.Ping mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPing.expectedInvocations, n)
	return mmPing
}

func (mmPing *mCacheMockPing) invocationsDone() bool {
	if len(mmPing.expectations) == 0 && mmPing.defaultExpectation == nil && mmPing.mock.funcPing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPing.mock.afterPingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Ping implements cache.Cache
func (mmPing *CacheMock) Ping(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmPing.beforePingCounter, 1)
	defer mm_atomic.AddUint64(&mmPing.afterPingCounter, 1)

	if mmPing.inspectFuncPing != nil {
		mmPing.inspectFuncPing(ctx)
	}

	mm_params := CacheMockPingParams{ctx}

	// Record call args
	mmPing.PingMock.mutex.Lock()
	mmPing.PingMock.callArgs = append(mmPing.PingMock.callArgs, &mm_params)
	mmPing.PingMock.mutex.Unlock()

	for _, e := range mmPing.PingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPing.PingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPing.PingMock.defaultExpectation.Counter, 1)
		mm_want := mmPing.PingMock.defaultExpectation.params
		mm_want_ptrs := mmPing.PingMock.defaultExpectation.paramPtrs

		mm_got := CacheMockPingParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPing.t.Errorf("CacheMock.Ping got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPing.t.Errorf("CacheMock.Ping got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPing.PingMock.defaultExpectation.results
		if mm_results == nil {
			mmPing.t.Fatal("No results are set for the CacheMock.Ping")
		}
		return (*mm_results).err
	}
	if mmPing.funcPing != nil {
		return mmPing.funcPing(ctx)
	}
	mmPing.t.Fatalf("Unexpected call to CacheMock.Ping. %v", ctx)
	return
}

// PingAfterCounter returns a count of finished CacheMock.Ping invocations
func (mmPing *CacheMock) PingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.afterPingCounter)
}

// PingBeforeCounter returns a count of CacheMock.Ping invocations
func (mmPing *CacheMock) PingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPing.beforePingCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Ping.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPing *mCacheMockPing) Calls() []*CacheMockPingParams {
	mmPing.mutex.RLock()

	argCopy := make([]*CacheMockPingParams, len(mmPing.callArgs))
	copy(argCopy, mmPing.callArgs)

	mmPing.mutex.RUnlock()

	return argCopy
}

// MinimockPingDone returns true if the count of the Ping invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockPingDone() bool {
	if m.PingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PingMock.invocationsDone()
}

// MinimockPingInspect logs each unmet expectation
func (m *CacheMock) MinimockPingInspect() {
	for _, e := range m.PingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Ping with params: %#v", *e.params)
		}
	}

	afterPingCounter := mm_atomic.LoadUint64(&m.afterPingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PingMock.defaultExpectation != nil && afterPingCounter < 1 {
		if m.PingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Ping")
		} else {
			m.t.Errorf("Expected call to CacheMock.Ping with params: %#v", *m.PingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPing != nil && afterPingCounter < 1 {
		m.t.Error("Expected call to CacheMock.Ping")
	}

	if !m.PingMock.invocationsDone() && afterPingCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Ping but found %d calls",
			mm_atomic.LoadUint64(&m.PingMock.expectedInvocations), afterPingCounter)
	}
}

type mCacheMockSet struct {
	optional           bool
	mock               *CacheMock
	defaultExpectation *CacheMockSetExpectation
	expectations       []*CacheMockSetExpectation

	callArgs []*CacheMockSetParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// CacheMockSetExpectation specifies expectation struct of the Cache.Set
type CacheMockSetExpectation struct {
	mock      *CacheMock
	params    *CacheMockSetParams
	paramPtrs *CacheMockSetParamPtrs
	results   *CacheMockSetResults
	Counter   uint64
}

// CacheMockSetParams contains parameters of the Cache.Set
type CacheMockSetParams struct {
	ctx   context.Context
	key   string
	value interface{}
}

// CacheMockSetParamPtrs contains pointers to parameters of the Cache.Set
type CacheMockSetParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *interface{}
}

// CacheMockSetResults contains results of the Cache.Set
type CacheMockSetResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mCacheMockSet) Optional() *mCacheMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for Cache.Set
func (mmSet *mCacheMockSet) Expect(ctx context.Context, key string, value interface{}) *mCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &CacheMockSetParams{ctx, key, value}
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for Cache.Set
func (mmSet *mCacheMockSet) ExpectCtxParam1(ctx context.Context) *mCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &CacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSet
}

// ExpectKeyParam2 sets up expected param key for Cache.Set
func (mmSet *mCacheMockSet) ExpectKeyParam2(key string) *mCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &CacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.key = &key

	return mmSet
}

// ExpectValueParam3 sets up expected param value for Cache.Set
func (mmSet *mCacheMockSet) ExpectValueParam3(value interface{}) *mCacheMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &CacheMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.value = &value

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the Cache.Set
func (mmSet *mCacheMockSet) Inspect(f func(ctx context.Context, key string, value interface{})) *mCacheMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for CacheMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by Cache.Set
func (mmSet *mCacheMockSet) Return(err error) *CacheMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &CacheMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &CacheMockSetResults{err}
	return mmSet.mock
}

// Set uses given function f to mock the Cache.Set method
func (mmSet *mCacheMockSet) Set(f func(ctx context.Context, key string, value interface{}) (err error)) *CacheMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the Cache.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the Cache.Set method")
	}

	mmSet.mock.funcSet = f
	return mmSet.mock
}

// When sets expectation for the Cache.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mCacheMockSet) When(ctx context.Context, key string, value interface{}) *CacheMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("CacheMock.Set mock is already set by Set")
	}

	expectation := &CacheMockSetExpectation{
		mock:   mmSet.mock,
		params: &CacheMockSetParams{ctx, key, value},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up Cache.Set return parameters for the expectation previously defined by the When method
func (e *CacheMockSetExpectation) Then(err error) *CacheMock {
	e.results = &CacheMockSetResults{err}
	return e.mock
}

// Times sets number of times Cache.Set should be invoked
func (mmSet *mCacheMockSet) Times(n uint64) *mCacheMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of CacheMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	return mmSet
}

func (mmSet *mCacheMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements cache.Cache
func (mmSet *CacheMock) Set(ctx context.Context, key string, value interface{}) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, key, value)
	}

	mm_params := CacheMockSetParams{ctx, key, value}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := CacheMockSetParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("CacheMock.Set got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSet.t.Errorf("CacheMock.Set got unexpected parameter key, want: %#v, got: %#v%s\n", *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSet.t.Errorf("CacheMock.Set got unexpected parameter value, want: %#v, got: %#v%s\n", *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("CacheMock.Set got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the CacheMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, key, value)
	}
	mmSet.t.Fatalf("Unexpected call to CacheMock.Set. %v %v %v", ctx, key, value)
	return
}

// SetAfterCounter returns a count of finished CacheMock.Set invocations
func (mmSet *CacheMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of CacheMock.Set invocations
func (mmSet *CacheMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to CacheMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mCacheMockSet) Calls() []*CacheMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*CacheMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *CacheMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *CacheMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CacheMock.Set with params: %#v", *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CacheMock.Set")
		} else {
			m.t.Errorf("Expected call to CacheMock.Set with params: %#v", *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Error("Expected call to CacheMock.Set")
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to CacheMock.Set but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), afterSetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CacheMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseInspect()

			m.MinimockExpireInspect()

			m.MinimockGetInspect()

			m.MinimockHDelInspect()

			m.MinimockHGetInspect()

			m.MinimockHSetInspect()

			m.MinimockPingInspect()

			m.MinimockSetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CacheMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CacheMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseDone() &&
		m.MinimockExpireDone() &&
		m.MinimockGetDone() &&
		m.MinimockHDelDone() &&
		m.MinimockHGetDone() &&
		m.MinimockHSetDone() &&
		m.MinimockPingDone() &&
		m.MinimockSetDone()
}
